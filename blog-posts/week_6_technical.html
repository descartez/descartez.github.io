<!DOCTYPE html>
<html lang="en">
<head>
 	<link rel="stylesheet" href="../stylesheets/blog-stylesheet.css">
 	<link href='http://fonts.googleapis.com/css?family=Asap|Expletus+Sans:600italic|Amaranth:400italic' rel='stylesheet' type='text/css'>
	<title>Dez does Dev</title>
</head>

<body>	
	<div id="wrapper">	
	<header>
		<a href="../index.html">Dez <span>does</span> Dev</a>
	</header>
	<nav>
		<ul>
			<li>
				<a href="blogs.html">posts</a>
			</li>
			<li>
				<a href="../projects/projects.html">projects</a>
			</li>
			<li>
				<a href="about.html">about</a>
			</li>
		</ul>
	</nav>
	<section id="content">
		<h1>
			Technical Post: Variable Scope
		</h1>
		<p>
			When you program, you have to make variables. That's gonna happen. But how does a program remember variables? Take a look at this program:
		</p>
		<pre>
thing = "A regular variable."

class Test


	attr_accessor :instance_var, :another_instance

	@@class_var = "This is a class variable"

	def initialize
		@instance_var = "This is an instance variable."
		@another_instance = "Another instance variable!"
	end

	$global = "A global variable"

	def inside_var
		other_var = "Just another regular variable."
	end

	def class_var_get
		@@class_var
	end

	def change_class_var
		@@class_var = "I changed the class variable!"
	end

end
		</pre>
		<p>
			What do you think it runs? Notice how we declare different variables? Sometimes we just use <code>variable = "variable</code> though you can also make variable equal numbers and all that jazz. other times we use <code>@@</code> of <code>@</code> or <code>$</code> before the variable name. Those set the scope. Look at what I declared each variable to equal for a description of what they are for.
		</p>
		<h1>
			Let's run the thing!
		</h1>
		<pre>
# First, let's initialize (aka make) our class, so they work.
# Notice how test1 and test2 are just different creations of
# the same class.

test1 = Test.new
test2 = Test.new

# Now let's try it out!

puts thing #thing is outside the class, so you can get it
			# even though it's a regular old variable

puts $global #this thing is accessible everywhere, even though
				# it's declared inside a class


puts test1.class_var_get #This will show us @@class_var
puts test2.change_class_var #this will change it everywhere, even though 
							# I've changed it using test2
puts test1.class_var_get #hey look! It changed!

puts test1.instance_var
puts test1.another_instance


puts other_var #this will throw an error

puts test1.inside_var #but this won't. I wonder why?
					# that's because other_var is local
					# only to the method it was declared in
		</pre>
		<p>
			So what will it look like?
		</p>
		<pre>
/home/dez/Git/DBC_stuff/descartez.github.io/blog-posts/variable_post.rb:56:in `<main>': undefined local variable or method `other_var' for main:Object (NameError)
A regular variable.
A global variable
This is a class variable
I changed the class variable!
I changed the class variable!
This is an instance variable.
Another instance variable!
		</pre>
		<p>
			I was right! Look at how it ran! Any variable with <code>$</code> at the front was accessible no matter where it was, class or no. <code>@@</code> variables were accessible and changed no matter which particular instance of a class was used. That means that you can change things for all objects that are of the same class, anywhere. And <code>@</code> variables were accessible as well, but if we had another class, that class could'nt access them, no matter what origins they share. Also, notice how <code>other_var</code> couldn't be accessed? We had to use the <code>inside_var</code> method to get at it. Local variables care about where they are declared. If they are declared outside of things, that's fine, but if they are inside a method, function, or class, they won't show up. Does that all make sense? Read the code again, try it yourself. The best way to learn is by doing, making mistakes, and seeing how to change them. Have fun!
		</p>
	</div>
</body>